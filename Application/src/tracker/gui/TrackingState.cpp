#include "TrackingState.h"
#include <tracking/Tracker.h>
#include <file/DataLocation.h>
#include <gui/GUITaskQueue.h>
#include <gui/Export.h>
#include <tracking/IndividualManager.h>
#include <tracking/PPFrame.h>
#include <tracking/Output.h>
#include <tracking/OutputLibrary.h>
#include <gui/WorkProgress.h>
#include <tracker/misc/default_config.h>
#include <misc/SettingsInitializer.h>
#include <misc/IdentifiedTag.h>

using namespace track;

namespace gui {

VIControllerImpl::VIControllerImpl(VIControllerImpl&& other) :
    vident::VIController(std::move((vident::VIController&)other)),
    _scene(other._scene),
    _current_percent(other._current_percent.load()),
    _busy(other._busy.load())
{}

void VIControllerImpl::on_tracking_ended(std::function<void()> fn) {
    _scene->_tracking_callbacks.push(fn);
}

void VIControllerImpl::on_apply_update(double percent) {
    _current_percent = percent;
    _busy = true;
}
void VIControllerImpl::on_apply_done() {
    _current_percent = 1;
    _busy = false;
}

VIControllerImpl::VIControllerImpl(pv::File& video, TrackingState& scene)
    : _scene(&scene)
{
    _video= &video;
    _tracker = scene.tracker.get();
    _analysis = &scene.analysis;
}

static constexpr Frame_t cache_size{Frame_t::number_t(10)};

TrackingState::TrackingState(GUITaskQueue_t* gui)
  : video(file::DataLocation::parse("output", SETTING(filename).value<file::Path>()), pv::FileMode::READ),
    tracker(std::make_unique<track::Tracker>(Image::Make(this->video.average()), this->video)),
    analysis(
      {
         [this](ConnectedTasks::Type&& ptr, auto&) -> bool {
             return stage_0(std::move(ptr));
         },
         [this](ConnectedTasks::Type&& ptr, auto&) -> bool {
             return stage_1(std::move(ptr));
         }
      }),
    pool(4u, "preprocess_main"),
    _controller(std::make_unique<VIControllerImpl>(video, *this))
{
    _end_task_check_auto_quit = [this, gui](){
#if !COMMONS_NO_PYTHON
            if(SETTING(auto_categorize)) {
                //GUI::auto_categorize();
            } else if(SETTING(auto_train)) {
                //GUI::auto_train();
            } else if(SETTING(auto_apply)) {
                //GUI::auto_apply();
            } else if(SETTING(auto_tags)) {
                auto message = "Can currently only use auto_tags in combination with '-load', when loading from a results file generated by TGrabs (where the tag information is stored). Please append '-load' to the command-line, for example, to load an existing results file.\nOtherwise please open a ticket at https://github.com/mooch443/trex, if you have a specific application for this kind of function (where TRex, not TGrabs, applies a network model to existing tag images).";
                if(SETTING(auto_tags_on_startup))
                    throw U_EXCEPTION(message);
                else
                    FormatWarning(message);
                
                //GUI::auto_tags();
            }
            
            // check if results should be saved and the app should quit
            // automatically after analysis is done.
            else
#endif
                if(SETTING(auto_quit))
            {
                analysis.terminate();
                _controller->auto_quit(gui);
            }
    };
}

TrackingState::~TrackingState() {
    if(_end_task.valid())
        _end_task.get();
}

bool TrackingState::stage_0(ConnectedTasks::Type && ptr) {
    auto idx = ptr->index();
    auto range = tracker->analysis_range();
    if(not range.contains(idx)
       && idx != range.end()
       && (not Tracker::end_frame().valid()
           || idx > Tracker::end_frame()))
    {
        std::unique_lock lock(_task_mutex);
        unused.emplace(std::move(ptr));
        return false;
    }

    if(not range.contains(idx))
        throw U_EXCEPTION("Outside of analysis range: ", idx, " vs. ", range);

    Timer timer;
    try {
        pv::Frame frame;
        video.read_frame(frame, idx);
        Tracker::preprocess_frame(std::move(frame), *ptr, pool.num_threads() > 1 ? &pool : NULL, PPFrame::NeedGrid::NoNeed, video.header().resolution, false);

        ptr->set_loading_time(timer.elapsed());
    }
    catch (const std::exception& e) {
        print("Error while preprocessing frame ", idx, ": ", e.what());
        return false;
    }

    // clear stored blob data, so that the destructor is called
    // in a different thread (balancing) if they arent needed.
    IndividualManager::clear_pixels();
    return true;
}

bool TrackingState::stage_1(ConnectedTasks::Type && ptr) {
    static Timer fps_timer;
    static Image empty(0, 0, 0);

    Timer timer;

    static Timing all_processing("Analysis::process()", 50);
    TakeTiming all(all_processing);

    LockGuard guard(w_t{}, "Analysis::process()");
    if(SETTING(terminate))
        return false;
    
    auto range = Tracker::analysis_range();

    auto idx = ptr->index();
    if (idx >= range.start()
        && max(range.start(), tracker->end_frame().valid()
                                ? (tracker->end_frame() + 1_f)
                                : 0_f)
           == idx
        && tracker->properties(idx) == nullptr
        && idx <= Tracker::analysis_range().end())
    {
        tracker->add(*ptr);

        static Timing after_track("Analysis::after_track", 10);
        TakeTiming after_trackt(after_track);
        
        if(idx + 1_f == video.length()
           || idx + 1_f > Tracker::analysis_range().end())
        {
            on_tracking_done();
        }
        
        static Timer last_added;
        if(last_added.elapsed() > 10) {
            tracker->global_segment_order();
            last_added.reset();
        }
        
        //print(_data->tracker->active_individuals(idx));
        _stats.update(idx, range, video.length(), tracker->statistics().at(idx).number_fish, idx == range.end());
    }

    static Timing procpush("Analysis::process::unused.push", 10);
    TakeTiming ppush(procpush);
    std::unique_lock lock(_task_mutex);
    unused.emplace(std::move(ptr));

    return true;
}

void TrackingState::init_video() {
    /*SettingsMaps combined;
    const auto set_combined_access_level = [&combined](auto& name, AccessLevel level) {
        combined.access_levels[name] = level;
    };
    
    grab::default_config::get(combined.map, combined.docs, set_combined_access_level);
    default_config::get(combined.map, combined.docs, nullptr);
    
    std::vector<std::string> save = combined.map.has("meta_write_these") ? combined.map.at("meta_write_these").value<std::vector<std::string>>() : std::vector<std::string>{};
    print("Have these keys:", combined.map.keys());
    std::set<std::string> deleted_keys;
    for(auto key : combined.map.keys()) {
        if(not contains(save, key)) {
            deleted_keys.insert(key);
            combined.map.erase(key);
        }
    }
    print("Deleted keys:", deleted_keys);
    print("Remaining:", combined.map.keys());

    thread_print("source = ", SETTING(source).value<file::PathArray>(), " ", (uint64_t)&GlobalSettings::map());
    GlobalSettings::map().set_print_by_default(true);
    //default_config::get(GlobalSettings::map(), GlobalSettings::docs(), &GlobalSettings::set_access_level);
    //default_config::get(GlobalSettings::set_defaults(), GlobalSettings::docs(), &GlobalSettings::set_access_level);
    
    auto&cmd = CommandLine::instance();
    for(auto &option : cmd.settings()) {
        if(utils::lowercase(option.name) == "output_prefix") {
            SETTING(output_prefix) = option.value;
        }
    }
    
    auto default_path = file::DataLocation::parse("default.settings");
    if(default_path.exists()) {
        DebugHeader("LOADING FROM ",default_path);
        default_config::warn_deprecated(default_path, GlobalSettings::load_from_file(default_config::deprecations(), default_path.str(), AccessLevelType::STARTUP));
        DebugHeader("LOADED ",default_path);
    }
    
    //cmd.load_settings(&combined);
    
    //! TODO: have to delegate this to another thread
    //! otherwise we will get stuck here
    bool executed_a_settings{false};
    thread_print("source = ", SETTING(source).value<file::PathArray>(), " ", (uint64_t)&GlobalSettings::map());*/
    
    if(video.header().version <= pv::Version::V_2) {
        SETTING(crop_offsets) = CropOffsets();
        
        file::Path settings_file = file::DataLocation::parse("settings");
        default_config::execute_settings_file(settings_file, AccessLevelType::STARTUP);
        
        auto output_settings = file::DataLocation::parse("output_settings");
        if(output_settings.exists() && output_settings != settings_file) {
            default_config::execute_settings_file(output_settings, AccessLevelType::STARTUP);
        }
    }
    
    /*
    print("meta_source_path = ", SETTING(meta_source_path).value<std::string>());
    print("track_max_individuals = ", SETTING(track_max_individuals).value<uint32_t>());
    print("exclude_parameters = ", exclude_parameters);

    try {
        if (!video.header().metadata.empty()) {
            sprite::parse_values(GlobalSettings::map(), video.header().metadata, &combined, exclude_parameters);
        }
    } catch(const UtilsException& e) {
        // dont do anything, has been printed already
    }*/
    
    SETTING(video_size) = Size2(video.size());
    SETTING(video_mask) = video.has_mask();
    SETTING(video_length) = uint64_t(video.length().get());
    SETTING(video_info) = std::string(video.get_info());
    
    if(SETTING(frame_rate).value<uint32_t>() <= 0) {
        FormatWarning("frame_rate == 0, calculating from frame tdeltas.");
        video.generate_average_tdelta();
        SETTING(frame_rate) = (uint32_t)max(1, int(video.framerate()));
    }
    
    Output::Library::InitVariables();
    Output::Library::Init();
    
    /*auto settings_file = file::DataLocation::parse("settings");
    if(settings_file.exists()) {
        if(default_config::execute_settings_file(settings_file, AccessLevelType::STARTUP, exclude_parameters))
            executed_a_settings = true;
        else {
            SETTING(settings_file) = file::Path();
            FormatWarning("Settings file ",settings_file," does not exist.");
        }
    }*/
    
    /**
     * Try to load Settings from the command-line that have been
     * ignored previously.
     */
    //cmd.load_settings(&combined);
    
    SETTING(gui_interface_scale) = float(1);
    print("cm_per_pixel = ", SETTING(cm_per_pixel).value<float>());
    
    for (auto i=0_f; i<cache_size; ++i)
        unused.emplace(std::make_unique<PPFrame>(tracker->average().bounds().size()));
    
    analysis.start(// main thread
        [this, &analysis = analysis, &please_stop_analysis = please_stop_analysis, &currentID = currentID, &tracker = tracker, &video = video]()
        {
            auto endframe = tracker->end_frame();
            if(not currentID.load().valid()
               || not endframe.valid()
               || currentID.load() > endframe + cache_size
               || (analysis.stage_empty(0) && analysis.stage_empty(1))
               || currentID.load() < endframe)
            {
                currentID = endframe; // update current as well
            }
        
            auto range = Tracker::analysis_range();
            if(not currentID.load().valid()
               or currentID.load() < range.start())
                currentID = range.start() - 1_f;
            
            if(not endframe.valid())
                endframe = range.start();
            
            if(FAST_SETTING(analysis_range).second != -1
               && endframe >= Frame_t(sign_cast<Frame_t::number_t>(FAST_SETTING(analysis_range).second))
               && !SETTING(terminate)
               && !please_stop_analysis)
            {
                please_stop_analysis = true;
                SETTING(analysis_paused) = true;
            }
            
            while(not currentID.load().valid()
                  || (currentID.load() < max(range.start(), endframe) + cache_size
                      && currentID.load() + 1_f < video.length()))
            {
                std::scoped_lock lock(_task_mutex);
                if(unused.empty())
                    break;
                
                auto ptr = std::move(unused.front());
                unused.pop();
                
                if(not currentID.load().valid())
                    currentID = range.start();
                else
                    currentID = currentID.load() + 1_f;
                ptr->set_index(currentID.load());
                
                analysis.add(std::move(ptr));
            }
        }
    );
}

void TrackingState::on_tracking_done() {
    please_stop_analysis = true;
    tracker->global_segment_order();
    SETTING(analysis_paused) = true;
    
    // tracking has ended
    while(not _tracking_callbacks.empty()) {
        _tracking_callbacks.front()();
        _tracking_callbacks.pop();
    }
    
    if(_end_task.valid())
        _end_task.get();
    _end_task = std::async(std::launch::async, _end_task_check_auto_quit);
}

void TrackingState::Statistics::calculateRates(double elapsed) {
    const auto frames_sec = frames_count / elapsed;
    frames_per_second = frames_sec;
    individuals_per_second = acc_individuals / sample_individuals;
    
    acc_frames += frames_sec;
    ++sample_frames;
    
    frames_count = 0;
    sample_individuals = 0;
    acc_individuals = 0;
}

void TrackingState::Statistics::printProgress(float percent, const std::string& status) {
    // Assuming we have a terminal width of 50 characters for the progress bar.
    constexpr int bar_width = 50;
    int pos = int(bar_width * (percent / 100.0f));

    printf("\r["); // Carriage return to overwrite the previous line
    for (int i = 0; i < bar_width; ++i) {
        if (i < pos) printf("=");
        else if (i == pos) printf(">"); // Indicator for current position
        else printf(" ");
    }
    printf("] %.2f%% %s", percent, status.c_str()); // Print the percentage and status message
    fflush(stdout); // Flush the output to ensure it appears immediately
}

void TrackingState::Statistics::logProgress(float percent, const std::string& status) {
    if (print_timer.elapsed() > 30) {
        // Here we use print(...) as if it's a member function similar to printf, but with
        // the behavior as specified (e.g., taking arbitrary arguments and producing reasonable
        // textual representations of objects, ending on a newline automatically).
        print("[Statistics] Progress: ", dec<2>(percent), "% ", status.c_str());
        print_timer.reset(); // Reset the timer to log again after the specified interval
    }
}

constexpr const char* time_unit() {
#if defined(__APPLE__)
    return "µs";
#else
    return "mus";
#endif
}

void TrackingState::Statistics::updateProgress(Frame_t frame, const FrameRange& analysis_range, Frame_t video_length, bool) {
    float percent = min(1.f, (frame - analysis_range.start()).get() / float(analysis_range.length().try_sub(1_f).get())) * 100.f;
    DurationUS us{ uint64_t(max(0, (double)(analysis_range.end() - frame).get() / double( acc_frames / sample_frames ) * 1000 * 1000)) };

    // Construct status string
    std::string status;
    auto prefix = FAST_SETTING(individual_prefix);
    if(frame == analysis_range.end()) {
        status = format<FormatterType::NONE>("Done (",
            dec<2>(frames_per_second.load()), "fps ",
            dec<2>(individuals_per_second.load()),"ind/s ",dec<2>(Tracker::average_seconds_per_individual() * 1000 * 1000), time_unit(), "/", prefix.c_str(),").") + "\n";
        printf("\r\n");

    } else if(FAST_SETTING(analysis_range).first != -1
       || FAST_SETTING(analysis_range).second != -1)
    {
        status = format<FormatterType::NONE>("frame ", frame, "/", analysis_range.end(), "(", video_length, ") @ ",
             dec<2>(frames_per_second.load()), "fps ", dec<2>(individuals_per_second.load()),"ind/s, eta ", us, ") ",
             dec<2>(Tracker::average_seconds_per_individual() * 1000 * 1000), time_unit(), "/", prefix.c_str()
        );
    } else {
        status = format<FormatterType::NONE>("frame ", frame, "/", analysis_range.end(), " (", dec<2>(frames_per_second.load()), "fps ",
             dec<2>(individuals_per_second.load()),"ind/s, eta ", us, ") ", dec<2>(Tracker::average_seconds_per_individual() * 1000 * 1000), time_unit(), "/", prefix.c_str()
        );
    }

    // Print progress to console
    printProgress(percent, status);

    // Log progress to file or wherever necessary
    logProgress(percent, status);
}


void TrackingState::Statistics::update(Frame_t frame, const FrameRange& analysis_range, Frame_t video_length, uint32_t num_individuals, bool force)
{
    frames_count++;
    acc_individuals += num_individuals;
    sample_individuals++;
    
    double elapsed = timer.elapsed();
    if ((elapsed >= 1 || force) && not analysis_range.empty()) {
        timer.reset();
        
        calculateRates(elapsed);
        updateProgress(frame, analysis_range, video_length, force);
    }
}

}
