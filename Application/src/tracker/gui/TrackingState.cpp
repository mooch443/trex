#include "TrackingState.h"
#include <tracking/Tracker.h>
#include <file/DataLocation.h>
#include <gui/GUITaskQueue.h>
#include <gui/Export.h>
#include <tracking/IndividualManager.h>
#include <tracking/PPFrame.h>
#include <tracking/Output.h>
#include <tracking/OutputLibrary.h>
#include <gui/WorkProgress.h>
#include <tracker/misc/default_config.h>
#include <misc/SettingsInitializer.h>
#include <misc/IdentifiedTag.h>
#include <tracking/Categorize.h>

using namespace track;

namespace gui {

VIControllerImpl::VIControllerImpl(VIControllerImpl&& other) :
    vident::VIController(std::move((vident::VIController&)other)),
    _scene(other._scene),
    _current_percent(other._current_percent.load()),
    _busy(other._busy.load())
{}

void VIControllerImpl::on_tracking_ended(std::function<void()> fn) {
    _scene->_tracking_callbacks.push(fn);
}

void VIControllerImpl::on_apply_update(double percent) {
    _current_percent = percent;
    _busy = true;
}
void VIControllerImpl::on_apply_done() {
    _current_percent = 1;
    _busy = false;
}

VIControllerImpl::VIControllerImpl(pv::File& video, TrackingState& scene)
    : _scene(&scene)
{
    _video= &video;
    _tracker = scene.tracker.get();
    _analysis = &scene.analysis;
}

static constexpr Frame_t cache_size{Frame_t::number_t(10)};

TrackingState::TrackingState(GUITaskQueue_t* gui)
  : video(file::DataLocation::parse("output", SETTING(filename).value<file::Path>()), pv::FileMode::READ),
    tracker(std::make_unique<track::Tracker>(Image::Make(this->video.average()), this->video)),
    analysis(
      {
         [this](ConnectedTasks::Type&& ptr, auto&) -> bool {
             return stage_0(std::move(ptr));
         },
         [this](ConnectedTasks::Type&& ptr, auto&) -> bool {
             return stage_1(std::move(ptr));
         }
      }),
    pool(4u, "preprocess_main"),
    _controller(std::make_unique<VIControllerImpl>(video, *this))
{
    _end_task_check_auto_quit = [this, gui](){
#if !COMMONS_NO_PYTHON
            if(SETTING(auto_categorize)) {
                //GUI::auto_categorize();
            } else if(SETTING(auto_train)) {
                //GUI::auto_train();
            } else if(SETTING(auto_apply)) {
                //GUI::auto_apply();
            } else if(SETTING(auto_tags)) {
                auto message = "Can currently only use auto_tags in combination with '-load', when loading from a results file generated by TGrabs (where the tag information is stored). Please append '-load' to the command-line, for example, to load an existing results file.\nOtherwise please open a ticket at https://github.com/mooch443/trex, if you have a specific application for this kind of function (where TRex, not TGrabs, applies a network model to existing tag images).";
                if(SETTING(auto_tags_on_startup))
                    throw U_EXCEPTION(message);
                else
                    FormatWarning(message);
                
                //GUI::auto_tags();
            }
            
            // check if results should be saved and the app should quit
            // automatically after analysis is done.
            else
#endif
                if(SETTING(auto_quit))
            {
                analysis.terminate();
                _controller->auto_quit(gui);
            }
    };
}

TrackingState::~TrackingState() {
    if(_end_task.valid())
        _end_task.get();
}

bool TrackingState::stage_0(ConnectedTasks::Type && ptr) {
    auto idx = ptr->index();
    auto range = tracker->analysis_range();
    if(not range.contains(idx)
       && idx != range.end()
       && (not Tracker::end_frame().valid()
           || idx > Tracker::end_frame()))
    {
        std::unique_lock lock(_task_mutex);
        unused.emplace(std::move(ptr));
        return false;
    }

    if(not range.contains(idx))
        throw U_EXCEPTION("Outside of analysis range: ", idx, " vs. ", range);

    Timer timer;
    try {
        pv::Frame frame;
        video.read_frame(frame, idx);
        Tracker::preprocess_frame(std::move(frame), *ptr, pool.num_threads() > 1 ? &pool : NULL, PPFrame::NeedGrid::NoNeed, video.header().resolution, false);

        ptr->set_loading_time(timer.elapsed());
    }
    catch (const std::exception& e) {
        print("Error while preprocessing frame ", idx, ": ", e.what());
        return false;
    }

    // clear stored blob data, so that the destructor is called
    // in a different thread (balancing) if they arent needed.
    IndividualManager::clear_pixels();
    return true;
}

bool TrackingState::stage_1(ConnectedTasks::Type && ptr) {
    static Timer fps_timer;
    static Image empty(0, 0, 0);

    Timer timer;

    static Timing all_processing("Analysis::process()", 50);
    TakeTiming all(all_processing);

    LockGuard guard(w_t{}, "Analysis::process()");
    if(SETTING(terminate))
        return false;
    
    auto range = Tracker::analysis_range();

    auto idx = ptr->index();
    if (idx >= range.start()
        && max(range.start(), tracker->end_frame().valid()
                                ? (tracker->end_frame() + 1_f)
                                : 0_f)
           == idx
        && tracker->properties(idx) == nullptr
        && idx <= Tracker::analysis_range().end())
    {
        tracker->add(*ptr);

        static Timing after_track("Analysis::after_track", 10);
        TakeTiming after_trackt(after_track);
        
        if(idx + 1_f == video.length()
           || idx + 1_f > Tracker::analysis_range().end())
        {
            on_tracking_done();
        }
        
        static Timer last_added;
        if(last_added.elapsed() > 10) {
            tracker->global_segment_order();
            last_added.reset();
        }
        
        //print(_data->tracker->active_individuals(idx));
        _stats.update(idx, range, video.length(), tracker->statistics().at(idx).number_fish, idx == range.end());
    }

    static Timing procpush("Analysis::process::unused.push", 10);
    TakeTiming ppush(procpush);
    std::unique_lock lock(_task_mutex);
    unused.emplace(std::move(ptr));

    return true;
}

void TrackingState::init_video() {
    /*SettingsMaps combined;
    const auto set_combined_access_level = [&combined](auto& name, AccessLevel level) {
        combined.access_levels[name] = level;
    };
    
    grab::default_config::get(combined.map, combined.docs, set_combined_access_level);
    default_config::get(combined.map, combined.docs, nullptr);
    
    std::vector<std::string> save = combined.map.has("meta_write_these") ? combined.map.at("meta_write_these").value<std::vector<std::string>>() : std::vector<std::string>{};
    print("Have these keys:", combined.map.keys());
    std::set<std::string> deleted_keys;
    for(auto key : combined.map.keys()) {
        if(not contains(save, key)) {
            deleted_keys.insert(key);
            combined.map.erase(key);
        }
    }
    print("Deleted keys:", deleted_keys);
    print("Remaining:", combined.map.keys());

    thread_print("source = ", SETTING(source).value<file::PathArray>(), " ", (uint64_t)&GlobalSettings::map());
    GlobalSettings::map().set_print_by_default(true);
    //default_config::get(GlobalSettings::map(), GlobalSettings::docs(), &GlobalSettings::set_access_level);
    //default_config::get(GlobalSettings::set_defaults(), GlobalSettings::docs(), &GlobalSettings::set_access_level);
    
    auto&cmd = CommandLine::instance();
    for(auto &option : cmd.settings()) {
        if(utils::lowercase(option.name) == "output_prefix") {
            SETTING(output_prefix) = option.value;
        }
    }
    
    auto default_path = file::DataLocation::parse("default.settings");
    if(default_path.exists()) {
        DebugHeader("LOADING FROM ",default_path);
        default_config::warn_deprecated(default_path, GlobalSettings::load_from_file(default_config::deprecations(), default_path.str(), AccessLevelType::STARTUP));
        DebugHeader("LOADED ",default_path);
    }
    
    //cmd.load_settings(&combined);
    
    //! TODO: have to delegate this to another thread
    //! otherwise we will get stuck here
    bool executed_a_settings{false};
    thread_print("source = ", SETTING(source).value<file::PathArray>(), " ", (uint64_t)&GlobalSettings::map());*/
    
    if(video.header().version <= pv::Version::V_2) {
        SETTING(crop_offsets) = CropOffsets();
        
        file::Path settings_file = file::DataLocation::parse("settings");
        default_config::execute_settings_file(settings_file, AccessLevelType::STARTUP);
        
        auto output_settings = file::DataLocation::parse("output_settings");
        if(output_settings.exists() && output_settings != settings_file) {
            default_config::execute_settings_file(output_settings, AccessLevelType::STARTUP);
        }
    }
    
    /*
    print("meta_source_path = ", SETTING(meta_source_path).value<std::string>());
    print("track_max_individuals = ", SETTING(track_max_individuals).value<uint32_t>());
    print("exclude_parameters = ", exclude_parameters);

    try {
        if (!video.header().metadata.empty()) {
            sprite::parse_values(GlobalSettings::map(), video.header().metadata, &combined, exclude_parameters);
        }
    } catch(const UtilsException& e) {
        // dont do anything, has been printed already
    }*/
    
    SETTING(video_size) = Size2(video.size());
    SETTING(video_mask) = video.has_mask();
    SETTING(video_length) = uint64_t(video.length().get());
    SETTING(video_info) = std::string(video.get_info());
    
    if(SETTING(frame_rate).value<uint32_t>() <= 0) {
        FormatWarning("frame_rate == 0, calculating from frame tdeltas.");
        video.generate_average_tdelta();
        SETTING(frame_rate) = (uint32_t)max(1, int(video.framerate()));
    }
    
    Output::Library::InitVariables();
    Output::Library::Init();
    
    /*auto settings_file = file::DataLocation::parse("settings");
    if(settings_file.exists()) {
        if(default_config::execute_settings_file(settings_file, AccessLevelType::STARTUP, exclude_parameters))
            executed_a_settings = true;
        else {
            SETTING(settings_file) = file::Path();
            FormatWarning("Settings file ",settings_file," does not exist.");
        }
    }*/
    
    /**
     * Try to load Settings from the command-line that have been
     * ignored previously.
     */
    //cmd.load_settings(&combined);
    
    SETTING(gui_interface_scale) = float(1);
    print("cm_per_pixel = ", SETTING(cm_per_pixel).value<float>());
    
    for (auto i=0_f; i<cache_size; ++i)
        unused.emplace(std::make_unique<PPFrame>(tracker->average().bounds().size()));
    
    analysis.start(// main thread
        [this, &analysis = analysis, &please_stop_analysis = please_stop_analysis, &currentID = currentID, &tracker = tracker, &video = video]()
        {
            auto endframe = tracker->end_frame();
            if(not currentID.load().valid()
               || not endframe.valid()
               || currentID.load() > endframe + cache_size
               || (analysis.stage_empty(0) && analysis.stage_empty(1))
               || currentID.load() < endframe)
            {
                currentID = endframe; // update current as well
            }
        
            auto range = Tracker::analysis_range();
            if(not currentID.load().valid()
               or currentID.load() < range.start())
                currentID = range.start() - 1_f;
            
            if(not endframe.valid())
                endframe = range.start();
            
            if(FAST_SETTING(analysis_range).second != -1
               && endframe >= Frame_t(sign_cast<Frame_t::number_t>(FAST_SETTING(analysis_range).second))
               && !SETTING(terminate)
               && !please_stop_analysis)
            {
                please_stop_analysis = true;
                SETTING(analysis_paused) = true;
            }
            
            while(not currentID.load().valid()
                  || (currentID.load() < max(range.start(), endframe) + cache_size
                      && currentID.load() + 1_f < video.length()))
            {
                std::scoped_lock lock(_task_mutex);
                if(unused.empty())
                    break;
                
                auto ptr = std::move(unused.front());
                unused.pop();
                
                if(not currentID.load().valid())
                    currentID = range.start();
                else
                    currentID = currentID.load() + 1_f;
                ptr->set_index(currentID.load());
                
                analysis.add(std::move(ptr));
            }
        }
    );
}

void TrackingState::on_tracking_done() {
    please_stop_analysis = true;
    tracker->global_segment_order();
    SETTING(analysis_paused) = true;
    
    // tracking has ended
    while(not _tracking_callbacks.empty()) {
        _tracking_callbacks.front()();
        _tracking_callbacks.pop();
    }
    
    if(_end_task.valid())
        _end_task.get();
    _end_task = std::async(std::launch::async, _end_task_check_auto_quit);
}

void TrackingState::Statistics::calculateRates(double elapsed) {
    const auto frames_sec = frames_count / elapsed;
    frames_per_second = frames_sec;
    individuals_per_second = acc_individuals / sample_individuals;
    
    acc_frames += frames_sec;
    ++sample_frames;
    
    frames_count = 0;
    sample_individuals = 0;
    acc_individuals = 0;
}

void TrackingState::Statistics::printProgress(float percent, const std::string& status) {
    // Assuming we have a terminal width of 50 characters for the progress bar.
    constexpr int bar_width = 50;
    int pos = int(bar_width * (percent / 100.0f));

    printf("\r["); // Carriage return to overwrite the previous line
    for (int i = 0; i < bar_width; ++i) {
        if (i < pos) printf("=");
        else if (i == pos) printf(">"); // Indicator for current position
        else printf(" ");
    }
    printf("] %.2f%% %s", percent, status.c_str()); // Print the percentage and status message
    fflush(stdout); // Flush the output to ensure it appears immediately
}

void TrackingState::Statistics::logProgress(float percent, const std::string& status) {
    if (print_timer.elapsed() > 30) {
        // Here we use print(...) as if it's a member function similar to printf, but with
        // the behavior as specified (e.g., taking arbitrary arguments and producing reasonable
        // textual representations of objects, ending on a newline automatically).
        print("[Statistics] Progress: ", dec<2>(percent), "% ", status.c_str());
        print_timer.reset(); // Reset the timer to log again after the specified interval
    }
}

constexpr const char* time_unit() {
#if defined(__APPLE__)
    return "Âµs";
#else
    return "mus";
#endif
}

void TrackingState::Statistics::updateProgress(Frame_t frame, const FrameRange& analysis_range, Frame_t video_length, bool) {
    float percent = min(1.f, (frame - analysis_range.start()).get() / float(analysis_range.length().try_sub(1_f).get())) * 100.f;
    DurationUS us{ uint64_t(max(0, (double)(analysis_range.end() - frame).get() / double( acc_frames / sample_frames ) * 1000 * 1000)) };

    // Construct status string
    std::string status;
    auto prefix = FAST_SETTING(individual_prefix);
    if(frame == analysis_range.end()) {
        status = format<FormatterType::NONE>("Done (",
            dec<2>(frames_per_second.load()), "fps ",
            dec<2>(individuals_per_second.load()),"ind/s ",dec<2>(Tracker::average_seconds_per_individual() * 1000 * 1000), time_unit(), "/", prefix.c_str(),").") + "\n";
        printf("\r\n");

    } else if(FAST_SETTING(analysis_range).first != -1
       || FAST_SETTING(analysis_range).second != -1)
    {
        status = format<FormatterType::NONE>("frame ", frame, "/", analysis_range.end(), "(", video_length, ") @ ",
             dec<2>(frames_per_second.load()), "fps ", dec<2>(individuals_per_second.load()),"ind/s, eta ", us, ") ",
             dec<2>(Tracker::average_seconds_per_individual() * 1000 * 1000), time_unit(), "/", prefix.c_str()
        );
    } else {
        status = format<FormatterType::NONE>("frame ", frame, "/", analysis_range.end(), " (", dec<2>(frames_per_second.load()), "fps ",
             dec<2>(individuals_per_second.load()),"ind/s, eta ", us, ") ", dec<2>(Tracker::average_seconds_per_individual() * 1000 * 1000), time_unit(), "/", prefix.c_str()
        );
    }

    // Print progress to console
    printProgress(percent, status);

    // Log progress to file or wherever necessary
    logProgress(percent, status);
}


void TrackingState::Statistics::update(Frame_t frame, const FrameRange& analysis_range, Frame_t video_length, uint32_t num_individuals, bool force)
{
    frames_count++;
    acc_individuals += num_individuals;
    sample_individuals++;
    
    double elapsed = timer.elapsed();
    if ((elapsed >= 1 || force) && not analysis_range.empty()) {
        timer.reset();
        
        calculateRates(elapsed);
        updateProgress(frame, analysis_range, video_length, force);
    }
}

void TrackingState::save_state(GUITaskQueue_t* gui, bool force_overwrite) {
    static bool save_state_visible = false;
    if(save_state_visible)
        return;
    
    save_state_visible = true;
    file::Path file = Output::TrackingResults::expected_filename();
    auto fn = [this, file, gui]() {
        bool before = analysis.is_paused();
        analysis.set_paused(true).get();
        
        LockGuard guard(w_t{}, "GUI::save_state");
        try {
            Output::TrackingResults results(*tracker);
            results.save([](const std::string& title, float x, const std::string& description){ WorkProgress::set_progress(title, x, description); }, file);
        } catch(const UtilsException&e) {
            auto what = std::string(e.what());
            if(gui)
                gui->enqueue([what](auto, DrawStructure& graph){
                    graph.dialog([](Dialog::Result){}, "Something went wrong saving the program state. Maybe no write permissions? Check out this message, too:\n<i>"+what+"</i>", "Error");
                });
            
            FormatExcept("Something went wrong saving program state. Maybe no write permissions?"); }
        
        if(!before)
            analysis.set_paused(false).get();
        
        save_state_visible = false;
    };
    
    if(file.exists() && !force_overwrite) {
        if(gui)
            gui->enqueue([fn, file = file](auto, DrawStructure& graph) mutable {
                graph.dialog([=](Dialog::Result result) mutable {
                    if(result == Dialog::Result::OKAY) {
                        WorkProgress::add_queue("Saving results...", fn);
                    } else if(result == Dialog::Result::SECOND) {
                        do {
                            if(file.remove_filename().empty()) {
                                file = file::Path("backup_" + file.str());
                            } else
                                file = file.remove_filename() / ("backup_" + (std::string)file.filename());
                        } while(file.exists());
                        
                        auto expected = Output::TrackingResults::expected_filename();
                        if(expected.move_to(file)) {
                            file = expected;
                            WorkProgress::add_queue("Saving backup...", fn);
                        //if(std::rename(expected.str().c_str(), file->str().c_str()) == 0) {
    //                          *file = expected;
    //                            work().add_queue("Saving backup...", fn);
                        } else {
                            FormatExcept("Cannot rename ",expected," to ",file,".");
                            save_state_visible = false;
                        }
                    } else
                        save_state_visible = false;
                    
                }, "Overwrite tracking previous results at <i>"+file.str()+"</i>?", "Overwrite", "Yes", "Cancel", "Backup old one");
            });
        else
            throw U_EXCEPTION("Cannot overwrite tracking results at ", file);
        
    } else
        WorkProgress::add_queue("Saving results...", fn);
}

void TrackingState::load_state(GUITaskQueue_t* gui, file::Path from) {
    static bool state_visible = false;
    if(state_visible)
        return;
    
    state_visible = true;

    auto fn = [this, from, gui]() {
        bool before = analysis.is_paused();
        analysis.set_paused(true).get();
        
        track::Categorize::DataStore::clear();
        
        LockGuard guard(w_t{}, "GUI::load_state");
        Output::TrackingResults results{*tracker};
        
        try {
            auto header = results.load([](const std::string& title, float value, const std::string& desc) {
                WorkProgress::set_progress(title, value, desc);
            }, from);
            
            if(header.version <= Output::ResultsFormat::Versions::V_33
               && Tracker::instance()->has_vi_predictions())
            {
                // probably need to convert blob ids
                pv::Frame f;
                size_t found = 0;
                size_t N = 0;
                
                Tracker::instance()->transform_vi_predictions([&](auto& k, auto& v) -> bool {
                    video.read_frame(f, k);
                    auto blobs = f.get_blobs();
                    N += v.size();
                    
                    for(auto &[bid, ps] : v) {
                        auto it = std::find_if(blobs.begin(), blobs.end(), [&bid=bid](auto &a)
                        {
                            return a->blob_id() == bid || a->parent_id() == bid;
                        });
                        
                        auto id = uint32_t(bid);
                        auto x = id >> 16;
                        auto y = id & 0x0000FFFF;
                        auto center = Vec2(x, y);
                        
                        if(it != blobs.end() || x > Tracker::average().cols || y > Tracker::average().rows) {
                            // blobs are probably fine
                            ++found;
                        } else {
                            
                        }
                    }
                    
                    if(found * 2 > N) {
                        // blobs are probably fine!
                        print("blobs are probably fine ",found,"/",N,".");
                        return false;
                    } else if(N > 0) {
                        print("blobs are probably not fine.");
                        return false;
                    }
                    
                    return true;
                });
                
                if(found * 2 <= N && N > 0) {
                    print("fixing...");
                    WorkProgress::set_item("Fixing old blob_ids...");
                    WorkProgress::set_description("This is necessary because you are loading an <b>old</b> .results file with <b>visual identification data</b> and, since the format of blob_ids has changed, we would otherwise be unable to associate the objects with said visual identification info.\n<i>If you want to avoid this step, please use the older TRex version to load the file or let this run and overwrite the old .results file (so you don't have to wait again). Be careful, however, as information might not transfer over perfectly.</i>\n");
                    auto old_id_from_position = [](Vec2 center) {
                        return (uint32_t)( uint32_t((center.x))<<16 | uint32_t((center.y)) );
                    };
                    /*auto old_id_from_blob = [&old_id_from_position](const pv::Blob &blob) -> uint32_t {
                        if(!blob.lines() || blob.lines()->empty())
                            return -1;
                        
                        const auto start = Vec2(blob.lines()->front().x0,
                                                blob.lines()->front().y);
                        const auto end = Vec2(blob.lines()->back().x1,
                                              blob.lines()->size());
                        
                        return old_id_from_position(start + (end - start) * 0.5);
                    };*/
                    
                    grid::ProximityGrid proximity{ Tracker::average().bounds().size() };
                    size_t i=0, all_found = 0, not_found = 0;
                    const size_t N = Tracker::instance()->number_vi_predictions();
                    ska::bytell_hash_map<Frame_t, ska::bytell_hash_map<pv::bid, std::vector<float>>> next_recognition;
                    
                    Tracker::instance()->transform_vi_predictions([&](auto& k, auto& v) {
                        auto & active = Tracker::active_individuals(k);
                        ska::bytell_hash_map<pv::bid, const pv::CompressedBlob*> blobs;
                        
                        for(auto fish : active) {
                            auto b = fish->compressed_blob(k);
                            if(b) {
                                auto bounds = b->calculate_bounds();
                                auto center = bounds.pos() + bounds.size() * 0.5;
                                blobs[b->blob_id()] = b;
                                proximity.insert(center.x, center.y, b->blob_id());
                            }
                        }
                        /*GUI::instance()->video_source()->read_frame(f, k.get());
                        auto & blobs = f.blobs();
                        proximity.clear();
                        for(auto &b : blobs) {
                            auto c = b->bounds().pos() + b->bounds().size() * 0.5;
                            proximity.insert(c.x, c.y, (uint32_t)b->blob_id());
                        }*/
                        
                        ska::bytell_hash_map<pv::bid, std::vector<float>> tmp;
                        
                        for(auto &[bid, ps] : v) {
                            auto id = uint32_t(bid);
                            auto x = id >> 16;
                            auto y = id & 0x0000FFFF;
                            auto center = Vec2(x, y);
                            
                            auto r = proximity.query(center, 1);
                            if(r.size() == 1) {
                                auto obj = std::get<1>(*r.begin());
                                assert(obj.valid());
                                /*auto ptr = std::find_if(blobs.begin(), blobs.end(), [obj](auto &b){
                                    return obj == (uint32_t)b->blob_id();
                                });*/
                                /*auto ptr = blobs.find(pv::bid(obj));
                                
                                if(ptr == blobs.end()) {
                                    FormatError("Cannot find actual blob for ", obj);
                                } else {
                                    //auto unpack = ptr->second->unpack();
                                    //print("Found ", center, " as ", obj, " vs. ", id, "(", old_id_from_blob(*unpack) ," / ", *unpack ,")");
                                }*/
                                    tmp[obj] = ps;
                                    ++all_found;
                                
                            } else {
                                const pv::CompressedBlob* found = nullptr;
                                video.read_frame(f, k);
                                for(auto &b : f.get_blobs()) {
                                    auto c = b->bounds().pos() + b->bounds().size() * 0.5;
                                    if(sqdistance(c, center) < 2) {
                                        //print("Found blob close to ", center, " at ", c, ": ", *b);
                                        for(auto &fish : active) {
                                            auto b = fish->compressed_blob(k);
                                            if(b && (b->blob_id() == bid || b->parent_id == bid))
                                            {
                                                //print("Equal IDS1 ", b->blob_id(), " and ", id);
                                                tmp[b->blob_id()] = ps;
                                                found = b;
                                                break;
                                            }
                                            
                                            if(b) {
                                                auto bounds = b->calculate_bounds();
                                                auto center = bounds.pos() + bounds.size() * 0.5;
                                                
                                                auto distance = sqdistance(c, center);
                                                //print("\t", fish->identity(), ": ", b->blob_id(), "(",b->parent_id,") at ", center, " (", distance, ")", (distance < 5 ? "*" : ""));
                                                
                                                if(distance < 2) {
                                                    tmp[b->blob_id()] = ps;
                                                    found = b;
                                                    break;
                                                }
                                            }
                                        }
                                        
                                        tmp[b->blob_id()] = ps;
                                        break;
                                    }
                                }
                                
                                if(found == nullptr) {
                                    //print("Not found for ", center, " size=", r.size(), " with id ", bid);
                                    ++not_found;
                                } else {
                                    ++all_found;
                                }
                            }
                        }
                        
                        //v = tmp;
                        next_recognition[k] = tmp;
                        
                        ++i;
                        if(i % uint64_t(N * 0.1) == 0) {
                            print("Correcting old-format pv::bid: ", dec<2>(double(i) / double(N) * 100), "%");
                            WorkProgress::set_percent(double(i) / double(N));
                        }
                    });
                    
                    print("Found:", all_found, " not found:", not_found);
                    if(all_found > 0)
                        Tracker::instance()->set_vi_data(next_recognition);
                }
            }
            
            {
                sprite::Map config;
                GlobalSettings::docs_map_t docs;
                default_config::get(config, docs, NULL);
                try {
                    default_config::load_string_with_deprecations(from.str(), header.settings, config, AccessLevelType::STARTUP, {}, true);
                    
                } catch(const cmn::illegal_syntax& e) {
                    print("Illegal syntax in .results settings (",e.what(),").");
                }
                
                std::vector<Idx_t> focus_group;
                if(config.has("gui_focus_group"))
                    focus_group = config["gui_focus_group"].value<std::vector<Idx_t>>();
                
                //if(GUI::instance() && !gui_frame_on_startup().frame.valid()) {
                //    WorkProgress::add_queue("", [f = Frame_t(header.gui_frame)](){
                        SETTING(gui_frame) = Frame_t(header.gui_frame);
                //    });
                //}
                
                //if(GUI::instance() && !gui_frame_on_startup().focus_group.has_value()) {
                //    WorkProgress::add_queue("", [focus_group](){
                        SETTING(gui_focus_group) = focus_group;
                //    });
                //}
                
            }
            
            if((header.analysis_range.start != -1 || header.analysis_range.end != -1) && SETTING(analysis_range).value<std::pair<long_t, long_t>>() == std::pair<long_t,long_t>{-1,-1})
            {
                SETTING(analysis_range) = std::pair<long_t, long_t>(header.analysis_range.start, header.analysis_range.end);
            }
            
            WorkProgress::add_queue("", [](){
                Tracker::instance()->check_segments_identities(false, IdentitySource::VisualIdent, [](float ) { },
                [](const std::string&t, const std::function<void()>& fn, const std::string&b)
                {
                    WorkProgress::add_queue(t, fn, b);
                });
            });
            
        } catch(const UtilsException& e) {
            FormatExcept("Cannot load results. Crashed with exception: ", e.what());
            
            auto what = std::string(e.what());
            if(gui)
                gui->enqueue([from, what](IMGUIBase*, DrawStructure& graph) {
                    graph.dialog([](Dialog::Result){}, "Cannot load results from '"+from.str()+"'. Loading crashed with this message:\n<i>"+what+"</i>", "Error");
                });
            
            auto start = Tracker::start_frame();
            Tracker::instance()->_remove_frames(start);
                //removed_frames(start);
        }
        
        //PD(analysis).reset_PD(cache);
        Output::Library::clear_cache();
        
        /*auto range = PD(tracker).analysis_range();
        bool finished = (PD(tracker).end_frame().valid() && PD(tracker).end_frame() == range.end()) || PD(tracker).end_frame() >= range.end();
#if !COMMONS_NO_PYTHON
        if(finished && SETTING(auto_categorize)) {
            auto_categorize();
        } else if(finished && SETTING(auto_train)) {
            auto_train();
        }
        else if(finished && SETTING(auto_apply)) {
            auto_apply();
        }
        else if(finished && SETTING(auto_tags)) {
            auto_tags();
        }
        else if(finished && SETTING(auto_quit)) {
#else
        if(finished && SETTING(auto_quit)) {
#endif
#if WITH_SFML
            if(has_window())
                window().setVisible(false);
#endif
            
            try {
                this->export_tracks();
            } catch(const UtilsException&) {
                SETTING(error_terminate) = true;
            }
            
            SETTING(terminate) = true;
        }
        
        if(GUI::instance() && (!before || (!finished && SETTING(auto_quit))))
            PD(analysis).set_paused(false).get();*/
        
        state_visible = false;
    };
    
    if(gui)
        gui->enqueue([fn = std::move(fn)](auto, DrawStructure& graph){
            graph.dialog([fn](Dialog::Result result) {
                if(result == Dialog::Result::OKAY) {
                    WorkProgress::add_queue("Loading results...", fn);
                } else {
                    state_visible = false;
                }
                
            }, "Are you sure you want to load results?\nThis will discard any unsaved changes.", "Load results", "Yes", "Cancel");
        });
    else
        WorkProgress::add_queue("Loading results...", fn);
}

}
